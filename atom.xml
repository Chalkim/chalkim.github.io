<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chalkim&#39;s Blog</title>
  
  
  <link href="https://blog.chalkim.ga/atom.xml" rel="self"/>
  
  <link href="https://blog.chalkim.ga/"/>
  <updated>2021-09-10T04:39:17.560Z</updated>
  <id>https://blog.chalkim.ga/</id>
  
  <author>
    <name>Chalkim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>求幂级数和函数的处理技巧汇总</title>
    <link href="https://blog.chalkim.ga/posts/2117448176/"/>
    <id>https://blog.chalkim.ga/posts/2117448176/</id>
    <published>2021-08-31T17:40:46.000Z</published>
    <updated>2021-09-10T04:39:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>　　本来想写“求幂级数和函数的一般方法”，但是感觉太标题党了，所谓的一般方法也不过是针对考研练习题的一般思路而已。而且我也不能保证所有的题目都能完美地套进去。“面向考研幂级数和函数设计”又显得过于中二，于是就干脆写成技巧汇总吧。</p><a id="more"></a><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>　　拿到题目应该有一个最基本的思路，就是先对幂级数进行一个预处理，把幂级数处理成方便操作的部分。比如对可拆分的分式进行拆分，提取齐次项等。</p><ol><li>计算收敛域，尤其是要注意收敛半径的边界是否收敛；</li><li>观察分子或分母是否可以拆分，如可拆则尝试拆成几个分式。</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>　　经过预处理的幂级数一般已经具备了可分析和函数的雏形，这里主要有两个类型。</p><ol><li>分母没有阶乘的，如 $\sum\limits_{n=0}^{\infty}\frac{x^n}{n(n+1)}$；</li><li>分母带有阶乘的，如 $\sum\limits_{n=0}^{\infty}\frac{n^2+1}{2^nn!}x^n$。</li></ol><p>　　分成这两类的理由是，我们根据幂级数写和函数的根据是常见幂级数的展开式。因此求和函数实际是一个逆操作的过程（其实是一种离散积分的感觉，幂级数表对应微分表）。观察<a href="/posts/369179661">常见幂级数表</a>，我们可以发现级数大致可以分为两类，一类不含阶乘（$\frac{1}{1+x}$, $\ln(1+x)$, $\arctan x$），另一类包含阶乘（$e^x$, $\sin x$, $\cos x$）。经过这样的分类后可以提高尝试的成功率。</p><h3 id="无阶乘类型"><a href="#无阶乘类型" class="headerlink" title="无阶乘类型"></a>无阶乘类型</h3><p>　　对于分母没有阶乘的，若级数逐项求导或逐次积分可化为更简单的形式，则优先进行求导或积分的操作。求导或积分的时候要注意求和起点的位置。</p><p>　　若级数可以明显看出具有某种常用幂级数的特征，则转到<a href="#对照展开式表得到和函数">对照展开式表得到和函数</a>。</p><h3 id="有阶乘类型"><a href="#有阶乘类型" class="headerlink" title="有阶乘类型"></a>有阶乘类型</h3><p>　　有阶乘的稍微麻烦一些，不过通过观察出现阶乘的条件，即和函数必须包含$e^x$, $\sin x$, $\cos x$之一。仔细看这几个函数，想起了什么？そうだ！二阶常系数齐次微分方程！</p><p>　　既然提到了微分方程，那么就一定要进行微分了，而且还要取高阶微分。直到得到一个与$y(x)$可以建立等式关系的高阶导数。此时可以从$x=0$入手，分别得到$y(0)$, $y’(0)$ …解此微分方程得到唯一解！</p><p>　　当然这只是一种特殊情况，更多的情况高阶导数和原级数不能建立等式关系。这些情况一般相对简单，也可通过逐项求导或逐项积分化简，从而<a href="#对照展开式表得到和函数">对照展开式表得到和函数</a>。</p><h3 id="对照展开式表得到和函数"><a href="#对照展开式表得到和函数" class="headerlink" title="对照展开式表得到和函数"></a>对照展开式表得到和函数</h3><p>　　到这一步我们已经很接近得到真正的和函数了，但在套公式之前仍然有一些需要处理的地方：</p><p>　　首先观察是否存在次数为 $kn$ 的常数项，若存在则先合并齐次项；然后通过简单的变形（通常是提 $x^k$ ），将式化为可直接写出和函数的形式。如下例：</p><script type="math/tex; mode=display">\begin{aligned}\sum_{n=1}^{\infty}\frac{1}{a^{kn}}x^{2n-1}=\frac{1}{x}\sum_{n=1}^{\infty}{(\frac{x^2}{a^{k}})}^n\end{aligned}</script><p>　　此时我们将会得到一个很容易套公式的级数，不用怀疑直接套就对了。或许求和起点不太一样，但是缺的项很容易单列出来从整体减掉。</p><p>　　若级数形如$\sum\limits_{n=0}^{\infty}kx^{n+a}$，直接套等比数列；</p><p>　　若级数形如$\sum\limits_{n=0}^{\infty}\frac{x^n}{n}$，直接套$\ln(1+x)$；</p><p>　　若级数形如$\sum\limits_{n=0}^{\infty}\frac{(-1)^nx^{2n+1}}{2n+1}$，直接套$\arctan x$；</p><p>　　若级数形如$\sum\limits_{n=0}^{\infty}\frac{x^n}{n!}$，直接套$e^x$；</p><p>　　若级数形如$\sum\limits_{n=0}^{\infty}\frac{(-1)^nx^{2n+1}}{(2n+1)!}$，直接套$\sin x$；</p><p>　　若级数形如$\sum\limits_{n=0}^{\infty}\frac{(-1)^nx^{2n}}{(2n)!}$，直接套$\cos x$；</p><h3 id="结束了？"><a href="#结束了？" class="headerlink" title="结束了？"></a>结束了？</h3><p>　　你以为解出来和函数就算完了吗？no no no</p><p>　　解出和函数还要看是不是其定义域是否完全包含收敛域。若有不符合的点（比如分母不为0，对数取值大于0等），要单独计算该点，写成分段函数的形式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　本来想写“求幂级数和函数的一般方法”，但是感觉太标题党了，所谓的一般方法也不过是针对考研练习题的一般思路而已。而且我也不能保证所有的题目都能完美地套进去。“面向考研幂级数和函数设计”又显得过于中二，于是就干脆写成技巧汇总吧。&lt;/p&gt;</summary>
    
    
    
    <category term="微积分" scheme="https://blog.chalkim.ga/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
    
    <category term="无穷级数" scheme="https://blog.chalkim.ga/tags/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>几种常用幂级数展开与和函数</title>
    <link href="https://blog.chalkim.ga/posts/369179661/"/>
    <id>https://blog.chalkim.ga/posts/369179661/</id>
    <published>2021-08-31T15:10:17.000Z</published>
    <updated>2021-09-10T04:39:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>　　这里总结了一些常用的幂级数结论，包括了常用级数展开的记忆方法。</p><a id="more"></a><h3 id="常见函数的级数展开"><a href="#常见函数的级数展开" class="headerlink" title="常见函数的级数展开"></a>常见函数的级数展开</h3><script type="math/tex; mode=display">\begin{equation}\begin{split}\frac{1}{1-x} = \sum_{n=0}^{\infty} x^n\end{split}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\begin{split}\frac{1}{1+x} = \sum_{n=0}^{\infty} (-1)^nx^n\end{split}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\begin{split}e^x = \sum_{n=0}^{\infty} \frac{x^n}{n!}\end{split}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\begin{split}\sin x = \sum_{n=0}^{\infty} \frac{(-1)^nx^{2n+1}}{(2n+1)!}\end{split}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\begin{split}\cos x = \sum_{n=0}^{\infty} \frac{(-1)^nx^{2n}}{(2n)!}\end{split}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\begin{split}\ln(1+x) = \sum_{n=1}^{\infty} \frac{(-1)^{n-1}x^{n}}{n}\end{split}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\begin{split}\arctan x&=\sum\limits_{n=0}^\infty\frac{(-1)^nx^{2n+1}}{2n+1}\end{split}\end{equation}</script><details><summary>$f(x)=\arctan x$</summary>$$\begin{aligned}f'(x)&=\frac{1}{1+x^2}=\sum\limits_{n=0}^\infty{(-1)}^nx^{2n}\\f(x) &= \int_{0}^{x}{f'(x)}\mathrm{d}x + f(0)\\&=\sum\limits_{n=0}^\infty\frac{(-1)^nx^{2n+1}}{2n+1}\end{aligned}$$</details><h3 id="部分幂级数记忆方法"><a href="#部分幂级数记忆方法" class="headerlink" title="部分幂级数记忆方法"></a>部分幂级数记忆方法</h3><div class="table-container"><table><thead><tr><th>$f(x)$</th><th>$x^0$</th><th>$x^1$</th><th>$x^2$</th><th>$x^3$</th><th>$x^4$</th><th>$x^5$</th></tr></thead><tbody><tr><td>$\sin x$</td><td></td><td>$1$</td><td></td><td>$-\frac{1}{3!}$</td><td></td><td>$\frac{1}{5!}$</td></tr><tr><td>$\cos x$</td><td>$1$</td><td></td><td>$-\frac{1}{2!}$</td><td></td><td>$\frac{1}{4!}$</td><td></td></tr><tr><td>$\tan x$</td><td></td><td>$1$</td><td></td><td>$\frac{1}{3}$</td><td></td><td></td></tr><tr><td>$e^x$</td><td>$1$</td><td>$\frac{1}{1!}$</td><td>$\frac{1}{2!}$</td><td>$\frac{1}{3!}$</td><td>$\frac{1}{4!}$</td><td>$\cdots$</td></tr><tr><td>$\ln(1+x)$</td><td></td><td>$1$</td><td>$-\frac{1}{2}$</td><td>$\frac{1}{3}$</td><td>$-\frac{1}{4}$</td><td>$\frac{1}{5}$</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　这里总结了一些常用的幂级数结论，包括了常用级数展开的记忆方法。&lt;/p&gt;</summary>
    
    
    
    <category term="微积分" scheme="https://blog.chalkim.ga/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
    
    <category term="无穷级数" scheme="https://blog.chalkim.ga/tags/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>利用二次型解决全微分方程变换问题</title>
    <link href="https://blog.chalkim.ga/posts/160094693/"/>
    <id>https://blog.chalkim.ga/posts/160094693/</id>
    <published>2021-08-26T18:06:18.000Z</published>
    <updated>2021-09-10T04:39:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>　　复习全微分部分的时候遇到一个感觉很眼熟的题目，仔细看了下，这不是二次型嘛哈哈哈。于是就用二次型的套路试了试，确实还做出来了。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>设变换<script type="math/tex">\begin{cases}u=x-2y,\\v=x+ay.\end{cases}(a\neq 2)</script>，可把方程<script type="math/tex">6\frac{\partial^2 z}{\partial x^2}+\frac{\partial^2 z}{\partial x\partial y}-\frac{\partial^2 z}{\partial y^2}=0</script>简化为<script type="math/tex">\frac{\partial^2 z}{\partial x\partial y}=0</script>，求常数<script type="math/tex">a</script>。</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>　　首先要完成偏导的变换，首先要找出<script type="math/tex">\frac{\partial z}{\partial x},\frac{\partial z}{\partial y}</script>与<script type="math/tex">\frac{\partial z}{\partial u},\frac{\partial z}{\partial v}</script>间的关系，进而表示出求二阶偏导，代入原方程化出只含有对<script type="math/tex">u, v</script>求偏导的式子。对比系数计算得到常数<script type="math/tex">a</script>。</p><p>　　这种方法虽然可以算出正确的结果，但是计算过程略显麻烦，尤其是求二阶混合偏导的时候计算量较大，容易产生错误。那么，是否存在简单易行的解决方案呢？</p><p>　　观察题目给出的方程，可以看出和二次型有相似之处。</p><script type="math/tex; mode=display">f(x_1,x_2)=x_1^2+6x_1x_2+5x_2^2=\left[\begin{array}{ccc}x_1&x_2\end{array}\right]\left[\begin{array}{ccc}1&3\\3&5\end{array}\right]\left[\begin{array}{ccc}x_1\\x_2\end{array}\right]</script><p>　　将二次型中的<script type="math/tex">x_1,x_2</script>分别替换成<script type="math/tex">\frac{\partial}{\partial x},\frac{\partial}{\partial y}</script>可以得到：</p><script type="math/tex; mode=display">原式=\left[\begin{array}{ccc}\frac{\partial}{\partial x}&\frac{\partial}{\partial y}\end{array}\right]\left[\begin{array}{ccc}6&0.5\\0.5&-1\end{array}\right]\left[\begin{array}{ccc}\frac{\partial}{\partial x}\\\frac{\partial}{\partial y}\end{array}\right]z</script><p>　　而坐标变换矩阵可以由全微分得到。</p><script type="math/tex; mode=display">\begin{cases}\mathrm{d}u=\mathrm{d}x-2\mathrm{d}y,\\\mathrm{d}v=\mathrm{d}x+a\mathrm{d}y.\end{cases}(a\neq 2)</script><script type="math/tex; mode=display">\mathrm{d}z=\frac{\partial z}{\partial x}\mathrm{d}x+\frac{\partial z}{\partial y}\mathrm{d}y=\frac{\partial z}{\partial u}\mathrm{d}u+\frac{\partial z}{\partial v}\mathrm{d}v</script><p>　　对照参数可得</p><script type="math/tex; mode=display">\left[\begin{array}{ccc}\frac{\partial}{\partial x}\\\frac{\partial}{\partial y}\end{array}\right]z=\left[\begin{array}{ccc}1&1\\-2&a\end{array}\right]\left[\begin{array}{ccc}\frac{\partial}{\partial u}\\\frac{\partial}{\partial v}\end{array}\right]z</script><p>　　则根据二次型合同公式可知</p><script type="math/tex; mode=display">{\left[\begin{array}{ccc}1&1\\-2&a\end{array}\right]}^{\mathrm{T}}\left[\begin{array}{ccc}6&0.5\\0.5&-1\end{array}\right]\left[\begin{array}{ccc}1&1\\-2&a\end{array}\right]=\left[\begin{array}{ccc}0&5+2.5a\\5+2.5a&6+a-a^2\end{array}\right]=\left[\begin{array}{ccc}0&k\\k&0\end{array}\right]</script><p>　　要使上述方程有解，则<script type="math/tex">a=3</script>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　复习全微分部分的时候遇到一个感觉很眼熟的题目，仔细看了下，这不是二次型嘛哈哈哈。于是就用二次型的套路试了试，确实还做出来了。&lt;/p&gt;</summary>
    
    
    
    <category term="微积分" scheme="https://blog.chalkim.ga/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
    
    <category term="全微分" scheme="https://blog.chalkim.ga/tags/%E5%85%A8%E5%BE%AE%E5%88%86/"/>
    
    <category term="二次型" scheme="https://blog.chalkim.ga/tags/%E4%BA%8C%E6%AC%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>中值定理与放缩法的联系以及在夹逼准则中的应用</title>
    <link href="https://blog.chalkim.ga/posts/1103454310/"/>
    <id>https://blog.chalkim.ga/posts/1103454310/</id>
    <published>2021-08-19T16:35:22.000Z</published>
    <updated>2021-09-10T04:39:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>　　写了一个很长的标题，但是其实没有什么复杂高深的地方，只是单纯不知道该怎么描述这个内容。缘由是写数列极限题的时候发现一类需要放缩法的问题，但是放缩的办法又和常规的想法不太一样，单纯记住不等式又心有不甘，于是就稍微研究了一下推导这种不等式的想法。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>设<script type="math/tex">x_n=(1+\frac{1}{n^2})(1+\frac{2}{n^2})\cdots(1+\frac{n}{n^2})</script>，则<script type="math/tex">\lim\limits_{n\to\infty}x_n</script>为何值？</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>　　观察到<script type="math/tex">x_n</script>是一个<script type="math/tex">n</script>项连乘的表达式，第一个想法就是取对数改为求和式，改写后的表达式为</p><script type="math/tex; mode=display">\lim\limits_{n\to\infty}{x_n}=e^{\lim\limits_{n\to\infty}\sum\limits_{i=1}^{n}\ln(1+\frac{i}{n^2})}</script><p>由于所求为无穷项求和，考虑夹逼准则或级数求和。这种级数没见过，也不会，直接推得放弃。考虑夹逼准则，一般而言是放缩分母或分子。首先通分得到$\ln(\frac{n^2+i}{n^2})$，可以尝试在分子上做文章，将<script type="math/tex">i</script>分别取上下限1,n，得到</p><script type="math/tex; mode=display">0\leq\lim\limits_{n\to\infty}\sum\limits_{i=1}^{n}\ln(1+\frac{i}{n^2})\leq1</script><p>左右两边不等，故放缩失败。</p><p>怎么办？看答案！</p><h3 id="另一种放缩方法"><a href="#另一种放缩方法" class="headerlink" title="另一种放缩方法"></a>另一种放缩方法</h3><p>　　若知不等式</p><script type="math/tex; mode=display">\frac{x}{x+1}\leq\ln(1+x)\leq x</script><p>则可以放缩为</p><script type="math/tex; mode=display">\frac{i}{n^2+n}\leq\frac{i}{n^2+i}=\frac{\frac{i}{n^2}}{\frac{i}{n^2}+1}\leq\ln(1+\frac{i}{n^2})\leq\frac{i}{n^2}</script><p>两边求和取极限可得到相等的值$\frac{1}{2}$,故原式为$e^\frac{1}{2}$。</p><h3 id="与中值定理的关系"><a href="#与中值定理的关系" class="headerlink" title="与中值定理的关系"></a>与中值定理的关系</h3><p>　　$\ln(1+x)\leq x$这部分很容易理解，但是如何理解缩小的部分呢？单纯背下来可不行。其实通过中值定律很容易推出来这个看起来似乎人人都应该知道的不等式。</p><p>　　首先令$f(x)=ln(x)$，对区间$(1,1+c)$列拉格朗日中值定理，有</p><script type="math/tex; mode=display">\frac{f(1+c)-f(1)}{1+c-1}=\frac{ln(1+c)}{c}=f'(\xi)=\frac{1}{\xi},\xi\in (1,1+c)</script><p>易知$\frac{1}{1+c}\leq\frac{1}{\xi}\leq 1$，同乘$c$可得上述不等式。</p><p>　　类似地，还可以整出来像$x\leq e^x-1 \leq xe^x$这样的东西，虽然我也不知道这玩意有啥用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　写了一个很长的标题，但是其实没有什么复杂高深的地方，只是单纯不知道该怎么描述这个内容。缘由是写数列极限题的时候发现一类需要放缩法的问题，但是放缩的办法又和常规的想法不太一样，单纯记住不等式又心有不甘，于是就稍微研究了一下推导这种不等式的想法。&lt;/p&gt;</summary>
    
    
    
    <category term="微积分" scheme="https://blog.chalkim.ga/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
    
    <category term="中值定理" scheme="https://blog.chalkim.ga/tags/%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/"/>
    
    <category term="放缩法" scheme="https://blog.chalkim.ga/tags/%E6%94%BE%E7%BC%A9%E6%B3%95/"/>
    
    <category term="夹逼准则" scheme="https://blog.chalkim.ga/tags/%E5%A4%B9%E9%80%BC%E5%87%86%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Jordan标准型与广义特征向量</title>
    <link href="https://blog.chalkim.ga/posts/2216331533/"/>
    <id>https://blog.chalkim.ga/posts/2216331533/</id>
    <published>2021-08-07T16:39:13.000Z</published>
    <updated>2021-09-10T04:39:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天做题的时候发现某教辅用心险恶地把Jordan标准型的内容加进来做习题内容，懂的人一眼就看明白怎么回事，不懂的人抓耳挠腮也想不明白。虽然并不是什么考纲规定的内容，但是还是有必要了解一下了。</p><a id="more"></a><h3 id="Jordan块"><a href="#Jordan块" class="headerlink" title="Jordan块"></a>Jordan块</h3><p>　　在介绍Jordan标准型之前有必要先介绍Jordan块。Jordan块首先是一个方阵，其形状类似对角矩阵，但也允许主对角线上方的对角线的系数为0或1。多说无益，直接举一个例子来看。</p><script type="math/tex; mode=display">{\displaystyle J={\begin{bmatrix}2&1&0&0\\0&2&1&0\\0&0&2&1\\0&0&0&2\end{bmatrix}}}</script><p>　　这样的一个矩阵块就称为4阶Jordan块，此外可以拓展到n阶。可以判断所有的1阶矩阵都可以看作一个1阶Jordan矩阵块。</p><h3 id="Jordan标准型"><a href="#Jordan标准型" class="headerlink" title="Jordan标准型"></a>Jordan标准型</h3><p>　　Jordan标准型同样形状类似对角矩阵，其对角线由一个或多个Jordan块构成。</p><script type="math/tex; mode=display">J={\begin{bmatrix}J_{1}&\;&\;\\\;&\ddots &\;\\\;&\;&J_{n}\end{bmatrix}}</script><p>　　同样举一个例子：</p><script type="math/tex; mode=display">{\displaystyle J={\begin{bmatrix}2&1&0\\0&2&0\\0&0&1\end{bmatrix}}}</script><p>　　可以看出对角矩阵可以视为Jordan标准型的一种特例。实际上，Jordan标准型可以认为是对角矩阵的一个扩展，其在许多方面的性质与对角矩阵类似。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>任何一个矩阵都相似于某个Jordan标准型；</li><li>主对角线的数字是原矩阵的特征值；</li><li>主对角线相同数字重复次数称为该特征值的代数重数（也就是原来的n重特征值）；</li><li>主对角线上属于特征值$\lambda_i$的Jordan块的个数称为该特征值的几何重数（也就是原来对应同一特征值的特征向量的基础解系中向量的个数）；</li><li>相似的Jordan标准型只有一个（如果不是对角矩阵，那么就不能相似对角化了。其几何重数小于代数重数，特征向量不能组成一个满秩的矩阵）。</li></ol><p>　　借用前例说明一下情况，其特征值分别为$\lambda_1=\lambda_2=2, \lambda_3=1$。其中特征值2的代数重数为2，几何重数为1。而特征值1的代数重数与几何重数均为1。</p><h3 id="广义特征向量"><a href="#广义特征向量" class="headerlink" title="广义特征向量"></a>广义特征向量</h3><p>　　我们都知道矩阵相似有以下公式</p><script type="math/tex; mode=display">\!P^{-1}AP=B</script><p>　　如果B为对角矩阵，则可逆矩阵P可以通过特征向量求出来（甚至可以Schmidt正交化求出合同变换的矩阵）。</p><script type="math/tex; mode=display">(A-{\lambda_i}E)\xi_i=0</script><p>　　对于Jordan标准型，为了达到类似的目的，我们引入广义特征向量的概念。</p><script type="math/tex; mode=display">(A-{\lambda_1}E)p_1=0</script><script type="math/tex; mode=display">(A-{\lambda_2}E)p_2=p_1</script><script type="math/tex; mode=display">(A-{\lambda_3}E)p_3=p_2</script><p>　　类似这样的$p_i$称为广义特征向量，由广义特征向量组成的矩阵$P$也是满秩的，该矩阵代入相似公式可以得到对应的Jordan标准型。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　如果考试出这种题目那是真的超没意思的，不过又有什么办法呢。题目出了一年又一年，应试教育也不是一天两天了。学生越来越会考试，不知道的人以为现在的大学生比以前多出多少能力一样。在这种情况下，不出点奇奇怪怪的题目属实是连命题老师都给整不会了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　今天做题的时候发现某教辅用心险恶地把Jordan标准型的内容加进来做习题内容，懂的人一眼就看明白怎么回事，不懂的人抓耳挠腮也想不明白。虽然并不是什么考纲规定的内容，但是还是有必要了解一下了。&lt;/p&gt;</summary>
    
    
    
    <category term="线性代数" scheme="https://blog.chalkim.ga/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
    <category term="Jordan标准型" scheme="https://blog.chalkim.ga/tags/Jordan%E6%A0%87%E5%87%86%E5%9E%8B/"/>
    
    <category term="特征向量" scheme="https://blog.chalkim.ga/tags/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础-多值依赖与4NF</title>
    <link href="https://blog.chalkim.ga/posts/3712086987/"/>
    <id>https://blog.chalkim.ga/posts/3712086987/</id>
    <published>2021-02-04T22:57:26.000Z</published>
    <updated>2021-09-10T04:39:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;BCNF并非完美的范式，满足BCNF的关系模式依然有改进的空间。于此相关的就是多值依赖与更进一步的范式：4NF。</p><a id="more"></a><p>&emsp;&emsp;假设学校里开设的每门课程都由多名教师讲授，使用相同的一套参考书。每个教师可以教授多门课程，每本参考书也可以供多门课程使用。有如下关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 课程     | 教师       | 参考书                           |</span><br><span class="line">|----------|------------|----------------------------------|</span><br><span class="line">| 物理     | 李勇、王军 | 普通物理学、光学原理、物理习题集 |</span><br><span class="line">| 数学     | 李勇、张平 | 数学分析、微分方程、高等代数     |</span><br><span class="line">| 计算数学 | 张平、周峰 | 数学分析...                      |</span><br><span class="line">| ...      | ...        | ...                              |</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将其规范化后有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">| 课程 | 教师 | 参考书     |</span><br><span class="line">|------|------|------------|</span><br><span class="line">| 物理 | 李勇 | 普通物理学 |</span><br><span class="line">| 物理 | 李勇 | 光学原理   |</span><br><span class="line">| 物理 | 李勇 | 物理习题集 |</span><br><span class="line">| 物理 | 王军 | 普通物理学 |</span><br><span class="line">| 物理 | 王军 | 光学原理   |</span><br><span class="line">| 物理 | 王军 | 物理习题集 |</span><br><span class="line">| 数学 | 李勇 | 数学分析   |</span><br><span class="line">| 数学 | 李勇 | 微分方程   |</span><br><span class="line">| 数学 | 李勇 | 高等代数   |</span><br><span class="line">| 数学 | 张平 | 数学分析   |</span><br><span class="line">| 数学 | 张平 | 微分方程   |</span><br><span class="line">| 数学 | 张平 | 高等代数   |</span><br><span class="line">| ...  | ...  | ...        |</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于该关系模型的码是（课程，教师，参考书），是全码（All-Key），因此满足BCNF的要求。尽管如此依然存在着种种缺陷。</p><p>&emsp;&emsp;如果我们要对某门课程增加（更改、删除）一本参考书，或者是增加一个教师。则必须对多个元组进行操作，这样的操作很麻烦，数据的冗余也很明显。而BCNF已经是考虑函数依赖规范化程度的极限了，实际上这种情况与另外一种数据依赖方式多值依赖相关。</p><h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><blockquote><p>&emsp;&emsp;设R(U)是属性集U上的一个关系模式。X、Y、Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X-&gt;-&gt;Y成立，当且仅当对R(U)的任一关系r，给定的一对(x,z)的值，有一组Y的值，这组值仅仅决定于x值而与z值无关。</p></blockquote><p>&emsp;&emsp;抽象的定义就介绍到这里。以我们上面的例子为例，对于一个（物理，普通物理学）有一组教师（李勇、王军），而教师只由课程物理决定，与普通物理学无关。因此课程-&gt;-&gt;教师，即教师多值依赖于课程。</p><p>&emsp;&emsp;相似的有对于一个（物理，李勇），都有一组参考书（普通物理学、光学原理、物理习题集）与之对应。而参考书与教师是不是李勇无关，只与课程物理有关系。因此课程-&gt;-&gt;参考书，即参考书多值依赖于课程。</p><div class="note warning">            <h4 id="注意与函数依赖的区别！"><a href="#注意与函数依赖的区别！" class="headerlink" title="注意与函数依赖的区别！"></a>注意与函数依赖的区别！</h4><ol><li><p>函数依赖是特殊的多值依赖。</p></li><li><p>函数依赖X-&gt;Y只与X和Y相关，而多值依赖则还与U中的其他属性Z相关。因此当属性集变大时，函数依赖依然存在，但多值依赖则可能消失。</p></li><li><p>若函数依赖X-&gt;Y成立，则对于Y的任意一个子集Y‘，都有X-&gt;Y’成立。而对于多值依赖则没有这样类似的结论。</p></li></ol>          </div><h3 id="4NF"><a href="#4NF" class="headerlink" title="4NF"></a>4NF</h3><p>&emsp;&emsp;关系模式R&lt;U,F&gt;满足1NF，若对于R的每一个<strong>非平凡多值依赖</strong>X-&gt;-&gt;Y，X都含有码，则称R&lt;U,F&gt;满足4NF。</p><blockquote><p>非平凡多值依赖就是Z不为空集的情况。实际上由于4NF定义X含有码，因此有X-&gt;Y。4NF所允许的非平凡多值依赖就是函数依赖。</p></blockquote><p><img src="/posts/3712086987/4NF_1.svg" alt="4NF_1"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;BCNF并非完美的范式，满足BCNF的关系模式依然有改进的空间。于此相关的就是多值依赖与更进一步的范式：4NF。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库基础" scheme="https://blog.chalkim.ga/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
    <category term="范式" scheme="https://blog.chalkim.ga/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E8%8C%83%E5%BC%8F/"/>
    
    
    <category term="范式" scheme="https://blog.chalkim.ga/tags/%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础-函数依赖与范式</title>
    <link href="https://blog.chalkim.ga/posts/3408363866/"/>
    <id>https://blog.chalkim.ga/posts/3408363866/</id>
    <published>2021-02-02T17:20:08.000Z</published>
    <updated>2021-09-10T04:39:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;为了设计出一个好的关系型数据库模式，需要按照规范化（Normalization）方法对关系模式进行优化。满足不同程度要求的规范化被称作范式。下面将在函数依赖的范畴内，依次讨论1NF、2NF、3NF与BCNF。</p><a id="more"></a><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>&emsp;&emsp;1NF要求每一个分量必须是不可分的数据项。简而言之就是不能表中有表：</p><blockquote><p><img src="/posts/3408363866/1NF_1.png" alt="1NF_1"></p></blockquote><p>&emsp;&emsp;这是最基本的规范化，满足1NF的数据库模式依然可能存在插入异常、删除异常、冗余过大的问题。</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>&emsp;&emsp;在满足1NF的基础上，每一个非主属性（Non-prime attribute）「即不出现在任何码中的属性」<strong>完全函数依赖</strong>于码（Key），则满足2NF。</p><h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><h5 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h5><p>&emsp;&emsp;对于函数依赖X-&gt;Y，有任意X的真子集X’，满足Y不函数依赖于X’，则X-&gt;Y称为完全函数依赖。</p><h5 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h5><p>&emsp;&emsp;不是完全函数依赖的就是部分函数依赖。</p><p>&emsp;&emsp;对于不满足2NF的关系模式，解决问题的方法是用投影将原关系模式为两个关系模式。</p><blockquote><p>&emsp;&emsp;学生-地址-选课关系(学号，系所，地址，课程号，成绩)</p><p>&emsp;&emsp;在这个关系中（学号，课程号）是码。学号唯一确定院系与住址，院系唯一确定住址，学号与课程号唯一确定成绩。在这个关系中存在非主属性部分函数依赖于码，如住址部分依赖于（学号，课程号）。</p><p><img src="/posts/3408363866/2NF_1.svg" alt="2NF_1"></p><p>&emsp;&emsp;分解为两个关系</p><p>&emsp;&emsp;学生-课程关系（学号，课程号，成绩），码是（学号，课程号）。</p><p>&emsp;&emsp;学生-地址关系（学号，系所，住址），码是学号。</p><p><img src="/posts/3408363866/2NF_2.svg" alt="2NF_2"></p><p>&emsp;&emsp;这样每一个关系内都不存在部分函数依赖于码的情况了。</p></blockquote><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>&emsp;&emsp;消除非主属性对码的传递函数依赖。即每一个非主属性既不部分依赖于码也不传递依赖于码。</p><p>&emsp;&emsp;X-&gt;Y, Y-&gt;Z, 但X不函数依赖于Y（如果有Y-&gt;X，则是X直接决定Z），则Z传递依赖于X。存在这样关系的关系模式则不符合3NF。</p><p>&emsp;&emsp;解决的方法是将关系模式分解。</p><blockquote><p>&emsp;&emsp;刚才分解后的学生-地址关系中包含非主属性对码的传递依赖。</p><p><img src="/posts/3408363866/3NF_1.svg" alt="3NF_1"></p><p>&emsp;&emsp;可以看到学号-&gt;系所（但没有系所-&gt;学号），系所-&gt;地址。因此按照传递依赖的定义，地址传递依赖于学号。（虽然有学号-&gt;地址但是和我们这里的传递依赖没关系）</p><p>&emsp;&emsp;由于地址是非主属性，因此这是不满足3NF的定义的，需要进行分解。</p><p><img src="/posts/3408363866/3NF_2.svg" alt="3NF_2"></p><p>&emsp;&emsp;学号-系所关系（学号，系所），码是学号。</p><p>&emsp;&emsp;系所-地址关系（系所，地址），码是系所。</p><p>&emsp;&emsp;分解后不存在非主属性对码的传递依赖，满足3NF</p></blockquote><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>&emsp;&emsp;要使一个关系模式满足BCNF，则至少要满足以下条件：</p><blockquote><ol><li><p>所有非主属性对每一个码都是完全函数依赖。</p></li><li><p>所有主属性对每一个不包含它的码也是完全函数依赖。</p></li><li><p>没有任何属性完全函数依赖于非码的任何一组属性。</p></li></ol></blockquote><p>&emsp;&emsp;其实比3NF就多了主属性对码也不能有部分或传递函数依赖。</p><blockquote><p>&emsp;&emsp;比分说下面这个例子</p><p>&emsp;&emsp;学生-教师-课程关系（学生，教师，课程）中，教师只教一门课，每门课对应多名教师。学生选定某门课就对应一名教师。</p><p>&emsp;&emsp;码有两个（学生，课程），（学生，教师）</p><p><img src="/posts/3408363866/BCNF_1.svg" alt="BCNF_1"></p><p>&emsp;&emsp;这里所有属性都是主属性，不存在非主属性，因此满足3NF。</p><p>&emsp;&emsp;但对于课程来说，教师直接决定课程。因此主属性课程对（学生，教师）部分函数依赖，不符合BCNF定义。</p><p>&emsp;&emsp;优化的方法依然是分解。</p><p><img src="/posts/3408363866/BCNF_2.svg" alt="BCNF_2"></p><p>&emsp;&emsp;学生-教师关系（学生，教师），码是学生。</p><p>&emsp;&emsp;教师-课程关系（教师，课程），码是教师。</p><p>&emsp;&emsp;这样就满足BCNF了。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>规范化过程：</p><p><img src="/posts/3408363866/summary_1.svg" alt="summary_1"></p><p>&emsp;&emsp;至此，关于函数依赖相关的范式介绍完毕，但尽管是满足BCNF的关系模式依然有所不足，这时就需要要求4NF进行约束。「关于4NF的讨论见<a href="/TODO">数据库基础-多值依赖与4NF</a>」</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;为了设计出一个好的关系型数据库模式，需要按照规范化（Normalization）方法对关系模式进行优化。满足不同程度要求的规范化被称作范式。下面将在函数依赖的范畴内，依次讨论1NF、2NF、3NF与BCNF。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库基础" scheme="https://blog.chalkim.ga/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
    <category term="范式" scheme="https://blog.chalkim.ga/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E8%8C%83%E5%BC%8F/"/>
    
    
    <category term="范式" scheme="https://blog.chalkim.ga/tags/%E8%8C%83%E5%BC%8F/"/>
    
    <category term="函数依赖" scheme="https://blog.chalkim.ga/tags/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础-关系代数与SQL</title>
    <link href="https://blog.chalkim.ga/posts/1189165209/"/>
    <id>https://blog.chalkim.ga/posts/1189165209/</id>
    <published>2021-01-31T18:22:33.000Z</published>
    <updated>2021-09-10T04:39:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;关系型数据库使用SQL语言进行操作，而关系代数是表达查询的一种抽象的查询语言。在了解SQL之前，有必要学习关系代数的表达方式。</p><a id="more"></a><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><ul><li><p>并：属于R或属于S的元组的集合，表示为<script type="math/tex">R\cup S</script>。</p></li><li><p>差：属于R但不属于S的元组的集合，表示为<script type="math/tex">R-S</script>。</p></li><li><p>交：既属于R又属于S的元组的集合，表示为<script type="math/tex">R\cap S</script>。</p></li><li><p>广义笛卡尔积：两个分别为n目和m目的关系R和S的笛卡尔积是一个(n+m)列的元组的集合。表示为<script type="math/tex">R\times S</script>。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R:                S:</span><br><span class="line">| A  | B  | C  |  | A  | B  |</span><br><span class="line">|----|----|----|  |----|----|</span><br><span class="line">| a1 | b1 | c1 |  | a2 | b1 |</span><br><span class="line">| a2 | b2 | c2 |  | a3 | b2 |</span><br><span class="line">| a3 | b3 | b4 |</span><br><span class="line"></span><br><span class="line">R×S:</span><br><span class="line">| A  | B  | C  | A  | B  |</span><br><span class="line">|----|----|----|----|----|</span><br><span class="line">| a1 | b1 | c1 | a2 | b1 |</span><br><span class="line">| a1 | b1 | c1 | a3 | b2 |</span><br><span class="line">| a2 | b2 | c2 | a2 | b1 |</span><br><span class="line">| a2 | b2 | c2 | a3 | b2 |</span><br><span class="line">| a3 | b3 | b4 | a2 | b1 |</span><br><span class="line">| a3 | b3 | b4 | a3 | b2 |</span><br></pre></td></tr></table></figure><h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4></li></ul><ol><li>选择（Selection）</li></ol><p>&emsp;&emsp;表示在关系R中选择满足给定条件的元组，表示为<script type="math/tex">\sigma_{\text{F}}(R)</script>，其中F表示选择条件。</p><p>&emsp;&emsp;eg:<script type="math/tex">\sigma_{\text{age<20}}(Student)</script></p><ol><li>投影（Projection）</li></ol><p>&emsp;&emsp;指从关系R中选择出某些属性列组成新的关系。由于取消了部分列，可能出现重复元组，应取消相同的行。表示为<script type="math/tex">\pi_\text{A}(R)</script>。</p><p>&emsp;&emsp;eg:<script type="math/tex">\pi_\text{dept}(Student)</script></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student            Projection:</span><br><span class="line">| Sname | Sdept |  | Sdept |</span><br><span class="line">|-------|-------|  |-------|</span><br><span class="line">| aaa   | CS    |  | CS    |</span><br><span class="line">| bbb   | IS    |  | IS    |</span><br><span class="line">| ccc   | IS    |</span><br></pre></td></tr></table></figure><ol><li>连接（Join）</li></ol><p>&emsp;&emsp;连接指从笛卡尔积中选择属性间满足某条件的元组。表示为<script type="math/tex">R{\bowtie\over{A\theta B}}S</script>。<script type="math/tex">\theta</script>是比较运算符。</p><p>&emsp;&emsp;<script type="math/tex">\theta</script>为<script type="math/tex">=</script>时，该连接运算称为<strong>等值连接</strong>。</p><p>&emsp;&emsp;自然连接是一种特殊的等值连接，要求比较的分量是相同的属性组，并去掉重复的属性列。记作<script type="math/tex">R\bowtie S</script></p><ol><li>除（Division）</li></ol><p>&emsp;&emsp;给定关系R(X, Y)和S(Y, Z)，其中X, Y, Z为属性组。表示为<script type="math/tex">R\div S</script>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">R            S            R÷S</span><br><span class="line">| X  | Y  |  | Y  | Z  |  | X  |</span><br><span class="line">|----|----|  |----|----|  |----|</span><br><span class="line">| x1 | y1 |  | y2 | z1 |  | x2 |</span><br><span class="line">| x2 | y1 |  | y2 | z2 |</span><br><span class="line">| x2 | y2 |  | y3 | z1 |</span><br><span class="line">| x2 | y3 |</span><br><span class="line">| x3 | y2 |</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看出除操作就是将S对Y属性投影，然后取出R中包含该投影集合的X，消去重复项目得到的集合。</p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>&emsp;&emsp;以上都是关系运算的数学表达，为了转化成数据库系统能够识别的表达，引入了SQL语言。下面将使用SQL语言对各类关系操作进行表示。</p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line"><span class="comment">/* 单表查询 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 查询所有属性列 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 查询计算值 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname, <span class="number">2021</span><span class="operator">-</span>Sage</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 消除重复行 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno           <span class="comment">-- 默认为ALL，即保留重复行</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 满足特定条件 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下两句等价 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> Sage <span class="operator">&gt;=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 范围 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sdept, Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sdept, Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 集合 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Ssex</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span> (<span class="string">&#x27;IS&#x27;</span>, <span class="string">&#x27;MA&#x27;</span>, <span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 字符匹配 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sno, Ssex    <span class="comment">-- % 代表任意长度字符串</span></span><br><span class="line"><span class="keyword">FROM</span> Student               <span class="comment">-- _ 代表任意单字符</span></span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="keyword">LIKE</span> <span class="string">&#x27;刘%&#x27;</span>;    <span class="comment">-- 刘xx，刘x，刘xxxxxx</span></span><br><span class="line">                           <span class="comment">-- +----------------+</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname               <span class="comment">-- |    \%    \_    |   转义</span></span><br><span class="line"><span class="keyword">FROM</span> Student               <span class="comment">-- +----------------+</span></span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="keyword">LIKE</span> <span class="string">&#x27;欧阳__&#x27;</span>; <span class="comment">-- 欧阳xx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="keyword">IS</span> <span class="keyword">NULL</span>;       <span class="comment">-- IS 不能换成 =</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多重条件 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> (Sdept<span class="operator">=</span><span class="string">&#x27;IS&#x27;</span> <span class="keyword">OR</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>) <span class="keyword">AND</span> Sage<span class="operator">&lt;</span><span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 排序 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno, Grade</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Grade <span class="keyword">DESC</span>;       <span class="comment">-- DESC 降序， ASC 升序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 集函数 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>);           <span class="comment">-- 统计元组个数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(Attr);        <span class="comment">-- 统计某一列值的个数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Attr);          <span class="comment">-- 计算某一列值总和</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Attr);          <span class="comment">-- 计算某一列平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Attr);          <span class="comment">-- 求某一列最大值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(Attr);          <span class="comment">-- 求某一列最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对结果分组 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Cno, <span class="built_in">COUNT</span>(Sno)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno;              <span class="comment">-- 按照Cno进行分组，具有相同Cno的元组分为一组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HAVING */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line"><span class="comment">/* 连接查询 */</span></span><br><span class="line"><span class="comment">/* 等值连接 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Student.<span class="operator">*</span>, SC.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno<span class="operator">=</span>SC.Sno;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自然连接 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade</span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno<span class="operator">=</span>SC.Sno;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自身连接 */</span></span><br><span class="line"><span class="keyword">SELECT</span> FIRST.Cno，SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span> Course <span class="keyword">FIRST</span>, Course <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno <span class="operator">=</span> SECOND.Cno;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 外连接 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade</span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno(<span class="operator">*</span>);    <span class="comment">-- 右外连接， *表示允许空值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复合条件连接 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">AND</span></span><br><span class="line">      SC.Cno<span class="operator">=</span><span class="string">&#x27;2&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">      SC.Grade<span class="operator">&gt;</span><span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line"><span class="comment">/* 嵌套查询 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname            <span class="comment">-- 父查询</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></span><br><span class="line">    <span class="keyword">SELECT</span> Sno          <span class="comment">-- 子查询</span></span><br><span class="line">    <span class="keyword">FROM</span> SC</span><br><span class="line">    <span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">&#x27;2&#x27;</span>;      <span class="comment">-- 子查询不能使用ORDER BY</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> Sage</span><br><span class="line">                 <span class="keyword">FROM</span> Student</span><br><span class="line">                 <span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;IS&#x27;</span>)</span><br><span class="line">      <span class="keyword">AND</span> Sdept <span class="operator">!=</span> <span class="string">&#x27;IS&#x27;</span>;          <span class="comment">-- 等价于Sage &lt; (SELECT MAX(Sage) ...)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="built_in">MAX</span>(<span class="keyword">SELECT</span> Sage</span><br><span class="line">                 <span class="keyword">FROM</span> Student</span><br><span class="line">                 <span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;IS&#x27;</span>)</span><br><span class="line">      <span class="keyword">AND</span> Sdept <span class="operator">!=</span> <span class="string">&#x27;IS&#x27;</span>;          <span class="comment">-- 等价于Sage &lt; (SELECT MIN(Sage) ...)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>                      <span class="comment">-- 返回 TRUE 或 FALSE</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">     <span class="keyword">FROM</span> SC</span><br><span class="line">     <span class="keyword">WHERE</span> Sno<span class="operator">=</span>Student.Sno <span class="keyword">AND</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line"><span class="comment">/* 集合查询 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span>              <span class="comment">-- 合并两个查询的结果，自动消除重复项</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage<span class="operator">&lt;=</span><span class="number">19</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;SELECT语句一般形式：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span> [别名] [, <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span> [别名]]...</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> [别名] [, <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> [别名]]...</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [<span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意的WHERE和HAVING的区别！</span></span><br><span class="line"><span class="comment">WHERE作用于表/视图，HAVING作用于组（GROUP）。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;关系型数据库使用SQL语言进行操作，而关系代数是表达查询的一种抽象的查询语言。在了解SQL之前，有必要学习关系代数的表达方式。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库基础" scheme="https://blog.chalkim.ga/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
    <category term="SQL" scheme="https://blog.chalkim.ga/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/SQL/"/>
    
    
    <category term="关系代数" scheme="https://blog.chalkim.ga/tags/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    
    <category term="SQL" scheme="https://blog.chalkim.ga/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>最优二叉搜索树算法</title>
    <link href="https://blog.chalkim.ga/posts/2679695428/"/>
    <id>https://blog.chalkim.ga/posts/2679695428/</id>
    <published>2021-01-29T15:46:12.000Z</published>
    <updated>2021-09-10T04:39:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最优二叉搜索树算法是一种<a href="/posts/766510942/">动态规划算法</a>。该算法解决的问题是：在给定结点出现频率的前提下，如何组织一颗二叉搜索树，使所有搜索操作访问的结点数最少？这也是一个最优解问题。</p><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>&emsp;&emsp;给定一个n个不同关键字的已排序的序列K，用该序列构建一颗二叉搜索树。对于每个关键字<script type="math/tex">k_i</script>，都有一个概率<script type="math/tex">p_i</script>表示其搜索频率。有些要搜索的值可能不在K中，应次还有n+1个伪关键字<script type="math/tex">d_0,d_1,\cdots,d_n</script>表示不在K中的值。$d_0$表示所有小于<script type="math/tex">k_1</script>的值，<script type="math/tex">d_n</script>表示所有大于<script type="math/tex">k_n</script>的值。对于每一个<script type="math/tex">d_i</script>,也有一个概率<script type="math/tex">q_i</script>表示其搜索频率。每次查找要么成功（找到某个关键字），要么失败（找到某个伪关键字）。</p><script type="math/tex; mode=display">\sum\limits_{i=1}^nP_i+\sum\limits_{i=0}^nq_i=1</script><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>&emsp;&emsp;一颗n=5的最优二叉树（期望搜索代价为2.75）：</p><div class="table-container"><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>$p_i$</td><td></td><td>0.15</td><td>0.10</td><td>0.05</td><td>0.10</td><td>0.20</td></tr><tr><td>$q_i$</td><td>0.05</td><td>0.10</td><td>0.05</td><td>0.05</td><td>0.05</td><td>0.10</td></tr></tbody></table></div><pre class="mermaid">graph TB  k2((k2))-->k1((k1))  k2-->k5((k5))  k1-->d0((d0))  k1-->d1((d1))  k5-->k4((k4))  k5-->d5((d5))  k4-->k3((k3))  k3-->d2((d2))  k3-->d3((d3))  k4-->d4((d4))</pre><script type="math/tex; mode=display">E[T中搜索代价]=1+\sum\limits_{i=1}^ndepth_T(k_i)\cdot p_i+\sum\limits_{i=1}^ndepth_T(d_i)\cdot q_i</script><h3 id="刻画最优子结构"><a href="#刻画最优子结构" class="headerlink" title="刻画最优子结构"></a>刻画最优子结构</h3><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>&emsp;&emsp;如果一颗最优二叉搜索树T有一颗包含关键字<script type="math/tex">k_i,\cdots ,k_j</script>的子树T‘，则其必然是包含关键字<script type="math/tex">k_i,\cdots ,k_j</script>和伪关键字<script type="math/tex">d_{i-1},\cdots ,d_{j}</script>的最优解。如果存在子树T’’，其期望搜索代价比T’低。则用T’’替换T’，则与T最优的假设矛盾。</p><p>&emsp;&emsp;因此我们可以利用最优子结构的性质，检查所有可能的根结点<script type="math/tex">k_i</script>，对其求解包含<script type="math/tex">k_i,\cdots ,k_{r-1}</script>及包含<script type="math/tex">k_{r+1},\cdots ,k_j</script>的最优二叉搜索树，即可找到原问题最优解。</p><h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><p>&emsp;&emsp;子问题域：求解包含关键字<script type="math/tex">k_i,\cdots,k_j</script>的最优二叉搜索树。<script type="math/tex">e[i,j]</script>为包含关键字<script type="math/tex">k_i,\cdots ,k_j</script>的最优二叉搜索树的期望代价。最终求出<script type="math/tex">e[1,n]</script>。</p><p>&emsp;&emsp;子树概率之和为</p><script type="math/tex; mode=display">w[i,j]=\sum\limits_{l=i}^jp_l+\sum\limits_{l=i-1}^jq_l</script><p>&emsp;&emsp;<script type="math/tex">j=i-1</script>时，子树只包含伪关键字<script type="math/tex">d_{i-1}</script>。</p><p>&emsp;&emsp;<script type="math/tex">i\leq j</script>时，子树<script type="math/tex">e[i,j]=p_r+(e[i,r-1]+w(i,r-1))+(e[r+1,j]+w(r+1,j))</script>，因为<script type="math/tex">w(i,j)=w(i,r-1)+p_r+w(r+1,j)</script>，可以得到如下递归公式：</p><script type="math/tex; mode=display">e[i,j]=\begin{cases}q_{i-1}&\text{若j=i-1}\\\min\limits_{i\leq r\leq j}\{e[i,r-1]+e[r+1,j]+w(i,j)\}&\text{若n>1}\end{cases}</script><h4 id="改为迭代算法"><a href="#改为迭代算法" class="headerlink" title="改为迭代算法"></a>改为迭代算法</h4><p>&emsp;&emsp;上述递归实现相对低效，用迭代算法进行改进。用表<script type="math/tex">e[1..n+1, 0..n]</script>保存<script type="math/tex">e[i,j]</script>。另外使用<script type="math/tex">root[i,j]</script>记录包含关键字<script type="math/tex">k_i,\cdots ,k_j</script>的子树的根。为了避免每次计算<script type="math/tex">e[i,j]</script>时都重新计算<script type="math/tex">w(i,j)</script>，使用表<script type="math/tex">w[1..n, 0..n]</script>保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">OPTIMAL-SET(p,q,n)</span><br><span class="line">&#x2F;&#x2F; p为关键字k_i的概率表，q为伪关键字d_i的概率表，n为问题规模</span><br><span class="line">    let e[1..n+1,0..n], w[1..n+1,0..n], and root[1..n, 1..n] be new tables</span><br><span class="line">&#x2F;&#x2F; 第一维上标为n+1是为了考虑只包含d[n+1]的情况</span><br><span class="line">&#x2F;&#x2F; 第二维下标为0是为了考虑只包含d[0]的情况</span><br><span class="line">    for i &#x3D; 1 to n+1</span><br><span class="line">        e[i,i-1] &#x3D; q[i-1]</span><br><span class="line">        w[i,i-1] &#x3D; q[i-1]                          &#x2F;&#x2F; 初始化</span><br><span class="line">    for l &#x3D; 1 to n                                 &#x2F;&#x2F; 子树宽度</span><br><span class="line">        for i &#x3D; 1 to n-l+1</span><br><span class="line">            j &#x3D; i+l-1                              &#x2F;&#x2F; 自底向上遍历所有可能的子树</span><br><span class="line">            e[i,j] &#x3D; inf                           &#x2F;&#x2F; 初始化</span><br><span class="line">            w[i,j] &#x3D; w[i, j-1] + p[j] + q[j]</span><br><span class="line">            for r &#x3D; i to j                         &#x2F;&#x2F; 选择根结点</span><br><span class="line">                t &#x3D; e[i,r-1] + e[r+1,j] + w[i,j]</span><br><span class="line">                if t &lt; e[i,j]                      &#x2F;&#x2F; 取最小值</span><br><span class="line">                    e[i,j]&#x3D;t</span><br><span class="line">                    root[i,j]&#x3D;r</span><br><span class="line">    return e and root</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行时间为<script type="math/tex">\theta (n^3)</script>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;最优二叉搜索树算法是一种&lt;a href=&quot;/posts/766510942/&quot;&gt;动态规划算法&lt;/a&gt;。该算法解决的问题是：在给定结点出现频率的前提下，如何组织一颗二叉搜索树，使所有搜索操作访问的结点数最少？这也是一个最优解问题。&lt;/p&gt;</summary>
    
    
    
    <category term="算法基础" scheme="https://blog.chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    <category term="动态规划" scheme="https://blog.chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="https://blog.chalkim.ga/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="二叉搜索树" scheme="https://blog.chalkim.ga/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法基础-动态规划</title>
    <link href="https://blog.chalkim.ga/posts/766510942/"/>
    <id>https://blog.chalkim.ga/posts/766510942/</id>
    <published>2021-01-26T23:40:11.000Z</published>
    <updated>2021-09-10T04:39:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;同<a href="/posts/561198911/">贪心算法</a>一样，动态规划所要解决的问题通常也是最优解问题。在策略上，动态规划与<a href="/2021/01/25/suan-fa-ji-chu-fen-zhi-fa/">分治法</a>相似，都是把复杂问题分解为数个子问题。不同的地方在于，分治法分解出的子问题均是独立的，即均需要进行单独的演算。而动态规划解决的是公共子问题，并将其保存以供重复利用，因此避免了大量不必要的计算工作。</p><a id="more"></a><p>&emsp;&emsp;一个动态规划算法的步骤大致有如下四步：</p><blockquote><ol><li>刻画一个最优解的结构特征。</li><li>递归地定义最优解的值。</li><li>计算最优解的值，通常采用自底向上的方法。</li><li>利用计算出的信息构造一个最优解。</li></ol></blockquote><h3 id="钢条切割问题"><a href="#钢条切割问题" class="headerlink" title="钢条切割问题"></a>钢条切割问题</h3><p>&emsp;&emsp;对于给定的一段长为n英寸的钢条和一个价格表<script type="math/tex">p_i</script>（样例如下）。</p><div class="table-container"><table><thead><tr><th>长度<script type="math/tex">i</script></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>价格<script type="math/tex">P_i</script></td><td>1</td><td>5</td><td>8</td><td>9</td><td>10</td><td>17</td><td>17</td><td>20</td><td>24</td><td>30</td></tr></tbody></table></div><p>&emsp;&emsp;假设切割所需的成本为0，如何切割钢条可以使收益<script type="math/tex">r_n</script>最大化？</p><p>&emsp;&emsp;应用动态规划的思想，我们将原问题分解为一系列子问题。</p><h4 id="最优解的结构特征"><a href="#最优解的结构特征" class="headerlink" title="最优解的结构特征"></a>最优解的结构特征</h4><p>&emsp;&emsp;对于一个钢条，我们总可以选择一个切割方案将钢条切成<script type="math/tex">k</script>段（<script type="math/tex">k=1</script>时表示不切割）如此一个最优解就应当是这种形式：</p><script type="math/tex; mode=display">n=i_1+i_2+\cdots+i_n</script><p>&emsp;&emsp;从而获取最大收益<script type="math/tex">r_n</script></p><script type="math/tex; mode=display">r_n=p_{i_1}+p_{i_2}+\cdots+p_{i_n}</script><p>&emsp;&emsp;考虑<script type="math/tex">n=1</script>的情况，只能选择不切割的方案，此时获取收益为1。考虑<script type="math/tex">n=2</script>的情况，可以选择不切割或切割为两个长度为1的钢条，取收益较大者即可。而对于更普遍的情况，实际上我们总能用如下表达式表示最大收益。</p><script type="math/tex; mode=display">r_n=max(p_n,r_1+r_{n-1},r_2+r_{n-2},\cdots,r_{n-1}+r_1)\tag{1}</script><blockquote><p><del>这里应该可以省去一半的计算量</del></p></blockquote><p>&emsp;&emsp;可以看出我们为了获取更普遍的情况，实际上是用子问题的最优解组合出最优解。因此我们说钢条切割问题具有<strong>最优子结构性质</strong>。</p><div class="note warning">            <h5 id="注意与分治法的区别！"><a href="#注意与分治法的区别！" class="headerlink" title="注意与分治法的区别！"></a>注意与分治法的区别！</h5><p>&emsp;&emsp;分治法不要求问题具有最优子结构性质，例如归并排序时我们只需要能够利用两子序列归并即可。但对于每一个子问题均是独立存在的，是需要单独计算的。而对于不具有最优子结构性质的问题，我们几乎就能断言其不适用动态规划了。</p>          </div><h4 id="递归地定义最优解的值"><a href="#递归地定义最优解的值" class="headerlink" title="递归地定义最优解的值"></a>递归地定义最优解的值</h4><p>&emsp;&emsp;简化<script type="math/tex">(1)</script>可以得到<script type="math/tex">r_n=\max\limits_{1\leq i\leq n}(p_i+r_{n-i})</script>。因此我们可以得到如下伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CUT-ROD(p, n)</span><br><span class="line">&#x2F;&#x2F; p为数组，即价格表；n为待处理钢条长度</span><br><span class="line">    if(n &#x3D;&#x3D; 0)                                 &#x2F;&#x2F; 长度为0没有收益</span><br><span class="line">        return 0</span><br><span class="line">    q &#x3D; -inf                                   &#x2F;&#x2F; 初始化</span><br><span class="line">    for i &#x3D; 1 to n</span><br><span class="line">        q &#x3D; max(q, p[i] + CUT-ROD(p,n - i))</span><br><span class="line">    return q</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，这个算法确实可以计算出最优解。但由于其递归实现，其时间复杂度相当巨大。分析n=3的情况，可以得到如下递归树。</p><pre class="mermaid">graph TB    n11((3))    n21((2))    n22((1))    n23((0))    n31((1))    n32((0))    n33((0))    n41((0))    n11---n21    n11---n22    n11---n23    n21---n31    n21---n32    n22---n33    n31---n41</pre><p>&emsp;&emsp;由递归树可知，对n个输入，对应结点数目为<script type="math/tex">2^n</script>个。其中有很多部分是重复的子问题，如果我们能够将其保存并加以利用，那么就可以降低算法的复杂度了。</p><blockquote><script type="math/tex; mode=display">T(n) =\begin{cases}1&\text{若n=0}\\\sum\limits_{j=0}^{n-1}T(j)&{其他}\end{cases}</script><p>可以证明<script type="math/tex">T(n)=2^n</script>，为一指数函数。实际上到这一步，对于分治法来说已经足够了，但对于动态规划还远远不够。</p></blockquote><h4 id="计算最优解的值"><a href="#计算最优解的值" class="headerlink" title="计算最优解的值"></a>计算最优解的值</h4><p>&emsp;&emsp;由于递归版本的算法运行时间太长，实用性很低，因此有必要进行改进。改进的方法一般有两种，一是<strong>带备忘的自顶向下法</strong>，二是<strong>自底向上法</strong>。</p><h5 id="带备忘的自顶向下法"><a href="#带备忘的自顶向下法" class="headerlink" title="带备忘的自顶向下法"></a>带备忘的自顶向下法</h5><p>&emsp;&emsp;如字面意思，该版本的改进在于在递归过程中加入了对子问题最优解值的保存。在需要子问题的解的时候，程序首先检查是否保存了该解，从而省去了计算的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 带备忘的自顶向下法的伪代码描述</span><br><span class="line">MEMOIZED-CUT-ROD(p, n)</span><br><span class="line">&#x2F;&#x2F; p为价格表，n为待处理钢条长度</span><br><span class="line">    let r[0..n] be a new array</span><br><span class="line">    for i &#x3D; 0 to n</span><br><span class="line">        r[i] &#x3D; -inf                                              &#x2F;&#x2F; 初始化备忘</span><br><span class="line">    return MEMOIZED-CUT-ROD-AUX(p, n, r)</span><br><span class="line"></span><br><span class="line">MEMOIZED-CUT-ROD-AUX(p, n, r)</span><br><span class="line">    if r[n] &gt;&#x3D; 0</span><br><span class="line">        return r[n]                                              &#x2F;&#x2F; 存在备忘直接取出</span><br><span class="line">    if n &#x3D;&#x3D; 0</span><br><span class="line">        q &#x3D; 0</span><br><span class="line">    else q &#x3D; -inf</span><br><span class="line">        for i &#x3D; 0 to n</span><br><span class="line">            q &#x3D; max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n-i ,r))</span><br><span class="line">    r[n] &#x3D; q                                                     &#x2F;&#x2F; 保存备忘</span><br><span class="line">    return q</span><br></pre></td></tr></table></figure><h5 id="自底向上法"><a href="#自底向上法" class="headerlink" title="自底向上法"></a>自底向上法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BOTTOM-UP-CUT-ROD(p, n)</span><br><span class="line">    let r[0..n] be a new array</span><br><span class="line">    r[0] &#x3D; 0</span><br><span class="line">    for j &#x3D; 1 to n</span><br><span class="line">        q &#x3D; -inf</span><br><span class="line">        for i &#x3D; 1 to j</span><br><span class="line">            q &#x3D; max(q, p[i] + r[j-i])</span><br><span class="line">        r[j]&#x3D;q</span><br><span class="line">    return r[n]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;与自顶向下法比较，可以发现自底向上法最重要的地方三添加了第4行，以及将递归调用改为直接从r中取出。由于用取值代替了递归调用，算法自然不能像递归算法一样一层层继续下去，因此有必要添加自底向上的迭代方法。</p><p>&emsp;&emsp;容易得到该改进版本运行时间为<script type="math/tex">\theta(n^2)</script>，实际上MEMOIZED-CUT-ROD运行时间也是上式。</p><h4 id="利用计算出的信息构造一个最优解"><a href="#利用计算出的信息构造一个最优解" class="headerlink" title="利用计算出的信息构造一个最优解"></a>利用计算出的信息构造一个最优解</h4><p>&emsp;&emsp;到这一步我们已经计算得到了最大收益的值，但实际上对于钢条的切割方案并未提供最优解。这一步就是要保存每一段切割长度<script type="math/tex">s_j</script>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXTENDED-BOTTOM-UP-CUT-ROD(p, n)</span><br><span class="line">    let r[0..n] and s[0..n] be new arrays                &#x2F;&#x2F; r是备忘，s是最优解</span><br><span class="line">    r[0] &#x3D; 0</span><br><span class="line">    for j &#x3D; 1 to n</span><br><span class="line">        q &#x3D; -inf</span><br><span class="line">        for i &#x3D; 1 to j</span><br><span class="line">            if q &lt; p[i] + r[j-i]</span><br><span class="line">                q &#x3D; p[i] + r[j-i]</span><br><span class="line">                s[j] &#x3D; i</span><br><span class="line">        r[j] &#x3D; q</span><br><span class="line">    return r and s</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;要应用动态规划解决问题，问题需要具备以下两个性质：<strong>最优子结构</strong>和<strong>子问题重叠</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;同&lt;a href=&quot;/posts/561198911/&quot;&gt;贪心算法&lt;/a&gt;一样，动态规划所要解决的问题通常也是最优解问题。在策略上，动态规划与&lt;a href=&quot;/2021/01/25/suan-fa-ji-chu-fen-zhi-fa/&quot;&gt;分治法&lt;/a&gt;相似，都是把复杂问题分解为数个子问题。不同的地方在于，分治法分解出的子问题均是独立的，即均需要进行单独的演算。而动态规划解决的是公共子问题，并将其保存以供重复利用，因此避免了大量不必要的计算工作。&lt;/p&gt;</summary>
    
    
    
    <category term="算法基础" scheme="https://blog.chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    <category term="动态规划" scheme="https://blog.chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="https://blog.chalkim.ga/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法基础-分治法</title>
    <link href="https://blog.chalkim.ga/posts/31632243/"/>
    <id>https://blog.chalkim.ga/posts/31632243/</id>
    <published>2021-01-25T22:47:42.000Z</published>
    <updated>2021-09-10T04:39:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;分治法是一种常见的算法设计思想。许多算法在结构上是递归的，这些算法采用的往往就是分治法。分治法的思想是将复杂问题分解为几个规模较小的但形式类似于原问题的子问题。递归地求解出子问题，再合并子问题的解，从而构建出原问题的解。</p><a id="more"></a><p>&emsp;&emsp;分治法在每层递归有三个步骤：</p><blockquote><ol><li>分解原问题为若干子问题；</li><li>解决子问题；</li><li>合并子问题的解，建立原问题的解。</li></ol></blockquote><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>&emsp;&emsp;其中一个典型的应用就是归并排序，上述三个步骤对应描述如下：</p><blockquote><ol><li>分解：将待排序的n个元素分解为两个包含n/2元素的子序列；</li><li>解决：使用归并排序递归地排序两个子序列；</li><li>合并：合并两个已排序的子序列。</li></ol></blockquote><p>&emsp;&emsp;由于算法是递归的，所以可以预见到递归的末端所需处理的子序列长度均为1。此时对于这些子序列不需我们进行任何多余工作即自然地满足排序的要求。</p><p>&emsp;&emsp;分解工作完成后，下一步操作就需要解决问题。解决问题的操作是调用了一个MERGE的辅助过程。该过程对两个已排好序的子序列进行合并，产生一个新的顺序序列。</p><p>&emsp;&emsp;对于MERGE具体的思想是：重复比较两个子序列的首个元素，取其中最小的元素，将其添加到新产生的顺序序列中。直到一个子序列的所有元素都被添加到新序列中，此时可以确保另外一个非空的子序列均比已经处理的元素要大。因此我们可以直接将其合并。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MERGE 伪代码描述</span><br><span class="line">MERGE(A, p, q, r)</span><br><span class="line">&#x2F;&#x2F; 其中A是一个数组。A[p, q]和A[q + 1, r]是已经排序的两个子序列。</span><br><span class="line">    n1 &#x3D; q - p + 1                       &#x2F;&#x2F; 序列1包含的元素数量</span><br><span class="line">    n2 &#x3D; r - q                           &#x2F;&#x2F; 序列2包含的元素数量</span><br><span class="line">    let L[1..n1+1] and R[1..n2+1] be new arrays</span><br><span class="line">    for i &#x3D; 1 to n1</span><br><span class="line">        L[i] &#x3D; A[p + i - 1]</span><br><span class="line">    for j &#x3D; 1 to n2</span><br><span class="line">        R[j] &#x3D; A[q + j]                  &#x2F;&#x2F; 复制</span><br><span class="line">    L[n1 + 1] &#x3D; inf                      &#x2F;&#x2F; 两个inf是标志算法可以停止的哨兵</span><br><span class="line">    R[n2 + 1] &#x3D; inf                      &#x2F;&#x2F; 这里是为了简化代码实现</span><br><span class="line">    i &#x3D; 1</span><br><span class="line">    j &#x3D; 1</span><br><span class="line">    for k &#x3D; p to r                       &#x2F;&#x2F; 假设j &#x3D; n2+1，则L[i]均比R[j]小</span><br><span class="line">        if L[i] &lt;&#x3D; R[j]                  &#x2F;&#x2F; 比较首元素大小</span><br><span class="line">            A[k] &#x3D; L[i]</span><br><span class="line">            i &#x3D; i + 1</span><br><span class="line">        else                             &#x2F;&#x2F; 放置较小的那一个</span><br><span class="line">            A[k] &#x3D; R[j]</span><br><span class="line">            j &#x3D; j + 1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们已经具备了完成该算法的所有条件了，让我们完成它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MERGE-SORT(A, p, r)</span><br><span class="line">&#x2F;&#x2F; A[p, r]是一个数组，即待排序序列</span><br><span class="line">    if p &lt; r</span><br><span class="line">        q &#x3D; (p + r) &#x2F; 2                  &#x2F;&#x2F; 向下取整</span><br><span class="line">        MERGE-SORT(A, p, q)</span><br><span class="line">        MERGE-SORT(A, q+1, r)            &#x2F;&#x2F; 分割原序列为两个序列</span><br><span class="line">        MERGE(A, p, q, r)                &#x2F;&#x2F; 合并两个已排序的子序列</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;值得注意的是，当A只含1项时该过程的行为。A.length = 1时，有p = r，不满足判断条件，即该过程什么都不做。两个长度为1的子序列MERGE成为一个长为2的新序列…</p><p>&emsp;&emsp;以此类推，自底向上，由小序列不断合成为新序列，最终完成原序列的排序工作。至此我们终于完成了归并排序的算法设计。</p><pre class="mermaid">graph BT    12[2 5]    1[5]-->|归并|12    2[2]-->|归并|12    34[4 7]    3[4]-->|归并|34    4[7]-->|归并|34    1234[2 4 5 7]    12-->|归并|1234    34-->|归并|1234</pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>&emsp;&emsp;我们知道归并排序最坏情况下的运行时间为<script type="math/tex">\theta(nlgn)</script>，而插入排序则为<script type="math/tex">\theta(n^2)</script>。显然归并排序在输入足够大的最坏情况下要快于插入排序。为什么？</p><p>&emsp;&emsp;分析程序运行步骤我们可以得到以下结论：</p><blockquote><ol><li>分解：将原序列分解为两个子序列，耗费<script type="math/tex">\theta(1)</script>时间</li><li>解决：递归地解决两个规模为n/2的子问题，耗费<script type="math/tex">2T(n/2)</script>时间</li><li>合并：MERGE过程最多需要处理n个元素，因此耗费<script type="math/tex">\theta(n)</script>时间</li></ol></blockquote><p>&emsp;&emsp;因此我们获得了最坏情况下T(n)的递归式：</p><script type="math/tex; mode=display">T(n)=\begin{cases}\theta(1)&\text{若n=1}\\2T(n/2)+\theta(n)&\text{若n>1}\end{cases}</script><p>&emsp;&emsp;为求解该表达式，我们需要引入一个定理。</p><blockquote><p>&emsp;&emsp;要求解<script type="math/tex">T(n)=aT(n/b)+f(n)</script>的渐进界，其中<script type="math/tex">a\geq1,b>1</script>为常数，<script type="math/tex">f(n)</script>为一个函数。<br>则有以下三种情况：</p><ol><li>若对某个常数<script type="math/tex">\epsilon>0</script>有<script type="math/tex">f(n)=O(n^{log_ba-\epsilon})</script>，则<script type="math/tex">T(n)=\theta(n^{log_ba})</script>。</li><li>若<script type="math/tex">f(n)=\theta(n^{log_ba})</script>，则<script type="math/tex">T(n)=\theta(n^{log_ba}lgn)</script>。</li><li>若对某个常数<script type="math/tex">\epsilon>0</script>有<script type="math/tex">f(n)=\Omega(n^{log_ba+\epsilon})</script>，且对某个常数<script type="math/tex">c<1</script>和所有足够大的<script type="math/tex">n</script>有<script type="math/tex">af(n/b)\leq cf(n)</script>，则<script type="math/tex">T(n)=\theta(f(n))</script>。</li></ol></blockquote><p>&emsp;&emsp;对于归并排序算法，我们有<script type="math/tex">a=2,b=2,f(n)=\theta(n)</script>，则<script type="math/tex">n^{log_ba}=n^{log_22}=n</script>，两者大小相当，应用情况2。于是我们求得<script type="math/tex">T(n)=\theta(nlgn)</script>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;分治法是一种常见的算法设计思想。许多算法在结构上是递归的，这些算法采用的往往就是分治法。分治法的思想是将复杂问题分解为几个规模较小的但形式类似于原问题的子问题。递归地求解出子问题，再合并子问题的解，从而构建出原问题的解。&lt;/p&gt;</summary>
    
    
    
    <category term="算法基础" scheme="https://blog.chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    <category term="分治法" scheme="https://blog.chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
    
    <category term="分治法" scheme="https://blog.chalkim.ga/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础-贪心算法</title>
    <link href="https://blog.chalkim.ga/posts/561198911/"/>
    <id>https://blog.chalkim.ga/posts/561198911/</id>
    <published>2021-01-22T21:45:52.000Z</published>
    <updated>2021-09-10T04:39:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在现实世界中我们会遇到一种问题：对于给定的n个输入，其解由这n个输入的某子集组成，该子集满足某种给定<strong>约束条件</strong>。对于某一问题来说，满足约束条件的<strong>可行解</strong>可能不止一个。为了衡量解的优劣，事先给出了判断的标准，即<strong>目标函数</strong>。使目标函数取得极值的解，即为<strong>最优解</strong>。</p><a id="more"></a><p>&emsp;&emsp;为了解决这类最优解问题，有线性规划、整数规划、非线性规划等等一系列算法。但对于其中的一些问题，可以用一种更直接的方法进行求解——贪心算法。</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>&emsp;&emsp;贪心算法是一种改进了的分级处理方法。首先根据问题选取一种度量方法；然后按照度量标准对n个输入排序，并按序一次输入一个量。如果该输入和当前已经构成的部分最优解加一起不能构成可行解，则不把该输入加入到解中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 贪心算法的伪代码描述</span><br><span class="line">procedure GREEDY(A, n)                           &#x2F;&#x2F; A(1 : n) 包含n个输入</span><br><span class="line">    solution &lt;- NULL                             &#x2F;&#x2F; 解向量初始化为空</span><br><span class="line">    for i &lt;- 1 to n do</span><br><span class="line">        x &lt;- SELECT(A)                           &#x2F;&#x2F; 按照某种度量方法选择一个输入</span><br><span class="line">        if FEASIBLE(solution, x)                 &#x2F;&#x2F; 判断包含x的集是否为可行解</span><br><span class="line">            then solution &lt;- UNION(solution, x)  &#x2F;&#x2F; 如可行，将x作为可行解的一部分</span><br><span class="line">        endif</span><br><span class="line">    repeat</span><br><span class="line">    return(solution)</span><br><span class="line">end GREEDY</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;要注意的是，许多量度标准取得的解并不是最优解，而是次优解。把目标函数作为量度标准的解也不一定是问题的最优解。实际上，选出最优量度标准不是是一件容易的事。</p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>&emsp;&emsp;设想这样一个场景：有一个最大承重<script type="math/tex">M</script>的背包，对于每种物品<script type="math/tex">i</script>的重量为<script type="math/tex">W_i</script>。假定当物品<script type="math/tex">i</script>的一部分<script type="math/tex">x_i</script>装入背包中可以获得<script type="math/tex">p_i x_i</script>的效益（<script type="math/tex">0 \leq x_i \leq 1, p_i > 0</script>）。求采用何种策略才能使得效益最大化？</p><p>&emsp;&emsp;以上问题可以用数学语言描述如下：</p><ul><li>目标函数（取极大值）<script type="math/tex; mode=display">\sum\limits_{1 \leq i \leq n} p_i x_i</script></li><li>约束条件<script type="math/tex; mode=display">\sum\limits_{1 \leq i \leq n} w_i x_i \leq M</script><script type="math/tex; mode=display">0 \leq x_i \leq 1 , p_i > 0, 1 \leq i \leq n</script></li></ul><p>&emsp;&emsp;自然我们会希望背包装的东西在占用重量少的情况下又尽可能地能产生更大的效益。因此，我们可以把<script type="math/tex">p_i / w_i</script>作为量度标准。经过测试，采用这种量度标准的贪心算法可以获得最优解。将物体按<script type="math/tex">p_i / w_i</script>的递减次序排序，则过程 GREEDY-KNAPSACK 就得出一个最优解。如果不考虑排序的时间，则算法的需要的时间为O(n)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">procedure GREEDY-KNAPSACK(P, W, M, X, n)</span><br><span class="line">    &#x2F;&#x2F; P(1:n)和W(1:n)分别含有按P(i)&#x2F;W(i) &gt;&#x3D; P(i+1)&#x2F;W(i+1)排序的n件物品的效益值和</span><br><span class="line">    &#x2F;&#x2F; 重量。M是背包的容量大小，X(1:n)是解向量。</span><br><span class="line">    real P(1:n), W(1:n), X(1:n), M, cu;</span><br><span class="line">    integer i, n;</span><br><span class="line">    X &lt;- 0     &#x2F;&#x2F; 将解向量初始化为0</span><br><span class="line">    cu &lt;- M    &#x2F;&#x2F; cu是背包剩余容量</span><br><span class="line">    for i &lt;- 1 to n do</span><br><span class="line">        if W(i) &gt; cu then exit endif</span><br><span class="line">        X(i) &lt;- 1</span><br><span class="line">        cu &lt;- cu - W(i)</span><br><span class="line">    repeat</span><br><span class="line">    if i &lt;&#x3D; n then X(i) &lt;- cu&#x2F;W(i)</span><br><span class="line">    endif</span><br><span class="line">end GREEDY-KNAPSACK</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由此可见，贪心算法的核心在于量度标准的选取。</p><h3 id="如何证明？"><a href="#如何证明？" class="headerlink" title="如何证明？"></a>如何证明？</h3><p>&emsp;&emsp;以上我们提到的关于背包问题的一种策略的解是最优解。我们该如何证明这一点呢？</p><p>&emsp;&emsp;有一个基本的想法是，把贪心算法的解与任一已知最优解作比较。如果这两个解不同，则按照解向量依次对<script type="math/tex">x_i</script>做替换。如果贪心解是最优解，那么在分量置换后的解也应当是个最优解，在背包问题中即总效应不变。重复执行这种替换，直到二者完全相同，就证明了贪心算法的解是最优解。</p><blockquote><p>设X=(1:n)是上述策略产生的贪心解。若所有的<script type="math/tex">x_i</script>都为1，则显然该解为最优解。</p><p>考虑不全为1的情况，由算法可知，存在一个j为<script type="math/tex">x_j \neq 1</script>的最小下标。若X不是一个最优解，则必然存在一个最优解Y使<script type="math/tex">\sum\limits_{1\leq i\leq n}p_iy_i>\sum\limits_{1\leq i\leq n}p_ix_i</script>。</p><p>设k是<script type="math/tex">y_k \neq x_k</script>的最小下标。从<script type="math/tex">k < j, k = j, k > j</script>三个方面展开讨论。</p><p>1）若<script type="math/tex">k < j</script>，则<script type="math/tex">x_k = 1</script>。由于<script type="math/tex">y_k < x_k</script>，从而<script type="math/tex">y_k < x_k</script>。</p><p>2）若<script type="math/tex">k = j</script>，由于<script type="math/tex">\sum w_j x_i = M</script>，且对<script type="math/tex">1 \leq i < j</script>，有<script type="math/tex">x_i = y_i = 1</script>，而对<script type="math/tex">j < i \leq n</script>，有<script type="math/tex">x_i = 0</script>。若<script type="math/tex">y_k > x_k</script>，则<script type="math/tex">\sum w_j y_i > M</script>，与题设矛盾。故<script type="math/tex">y_k < x_k</script>。</p><p>3）若<script type="math/tex">k > j</script>，显然这是不可能的。</p><p>由此我们得到了<script type="math/tex">y_k < x_k</script>的结论。</p><p>现在假设我们把<script type="math/tex">y_k</script>增加到<script type="math/tex">x_k</script>，则需要从<script type="math/tex">(y_{k+1}, y_{k+2},...,y_n)</script>中减去同样多的量。使总量仍然为M。这就导致了一个新解Z。且有<script type="math/tex">\sum\limits_{k<i\leq n} w_i(y_i - z_i) = w_k(z_k -y_k)</script>。</p><script type="math/tex; mode=display">\begin{align}\sum\limits_{1\leq i \leq n}p_iz_i &= \sum\limits_{1\leq i\leq n}p_iy_i+(z_k-y_k)w_kp_k/w_k - \sum\limits_{k<i\leq n}(y_i-z_i)w_ip_i/w_i\\&\geq \sum\limits_{1\leq i\leq n}p_iy_i+[(z_k-y_k)w_k-\sum\limits_{k<i\leq n}(y_i-z_i)w_i]p_i/w_k\\&= \sum\limits_{1\leq i\leq n}p_iy_i\end{align}</script><p>若<script type="math/tex">\sum p_iz_i>\sum p_iy_i</script>，则Y不可能是最优解。若取等，<script type="math/tex">Z=X</script>，则<script type="math/tex">X</script>为最优解；若<script type="math/tex">Z\neq X</script>，则需重复以上讨论，或者证明Y不是最优解，或者把Y转换成X，从而证明X也是最优解。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;在现实世界中我们会遇到一种问题：对于给定的n个输入，其解由这n个输入的某子集组成，该子集满足某种给定&lt;strong&gt;约束条件&lt;/strong&gt;。对于某一问题来说，满足约束条件的&lt;strong&gt;可行解&lt;/strong&gt;可能不止一个。为了衡量解的优劣，事先给出了判断的标准，即&lt;strong&gt;目标函数&lt;/strong&gt;。使目标函数取得极值的解，即为&lt;strong&gt;最优解&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="算法基础" scheme="https://blog.chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    <category term="贪心算法" scheme="https://blog.chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="贪心算法" scheme="https://blog.chalkim.ga/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
